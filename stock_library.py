
# coding: utf-8

# # stock.py

# In[ ]:


get_ipython().run_cell_magic('writefile', 'stock.py', '# coding: utf-8\n\n# from __future__ import unicode_literals\nimport numpy as np\nimport pandas as pd\nimport pandas.tseries.offsets as offsets\nimport datetime as dt\nimport time\nimport importlib\nimport logging\nfrom retry import retry\n# import traceback\n# from retrying import retry\n\n\n# パスの設定\ncsv_path = \'D:\\stockyard\\_csv\'\nprice_path = \'D:\\stockyard\\_yahoo_csv\'\n# csv_path = \'/home/hideshi_honma/stockyard/_csv\'\n# price_path = \'/home/hideshi_honma/stockyard/_yahoo_csv\'\n\n    \ndef get_jpx_expro_code(start_index=0, end_index=None, csv_path=csv_path):\n    jpx_expro = pd.read_csv(\'{0}/jpx_expro.csv\'.format(csv_path), index_col=0)\n\n    if end_index == None:\n        end_index = len(jpx_expro)\n\n    result = list(jpx_expro[\'code\'][start_index : end_index])\n\n    return result\n    \n    \ndef get_jpx_new_added_code(start_index=0, end_index=None, csv_path=csv_path):\n    jpx_new_added = pd.read_csv(\'{0}/jpx_new_added.csv\'.format(csv_path), index_col=0)\n\n    if end_index == None:\n        end_index = len(jpx_new_added)\n\n    result = list(jpx_new_added[\'code\'][start_index : end_index])\n\n    return result\n\n\ndef get_stooq_ticker():\n    result = []\n    p = 1\n    base = \'https://stooq.com/t/tr/?l={0}\'\n\n    while True:\n    # while p < 4: # テスト用\n        url = base.format(p)\n        # \'https://stooq.com/t/tr/?o=4&l=1\' # 2018-04-01 l=1195まで\n        print(\'{0}: {1}\'.format(p, url))\n        tables = get_table(url)\n        if len(tables[25]) == 0:\n            break\n        result.append(tables[25])\n        p += 1\n        \n    result = pd.concat(result, ignore_index=True)\n    result = result[[\'Ticker\', \'Market\', \'Price change 1D\']]\n    result.columns = [\'ticker\', \'name\', \'market\']\n    result[\'market\'] = result[\'market\'].fillna("")\n    result = result.sort_values(by=[\'market\', \'name\'])\n    result = result.drop_duplicates().reset_index(drop=True)\n    \n    return result\n    \n    \ndef get_yahoo_code(start_index=0, end_index=None, csv_path=csv_path):\n    table = pd.read_csv(\'{0}/yahoo_stock_table.csv\'.format(csv_path), index_col=0)\n    table = table.append(pd.read_csv(\'{0}/yahoo_etf_table.csv\'.format(csv_path), index_col=0))\n    table = table.drop_duplicates(\'code\')\n    table = table.sort_values(by=[\'code\']).reset_index(drop=True)\n\n    if (end_index == None) or (end_index > len(table)):\n        end_index = len(table)\n\n    result = list(table[\'code\'][start_index : end_index])\n    # result = table.loc[start_index:end_index, [\'code\', \'market_code\']]\n\n    return result\n\n\ndef get_yahoo_info(csv_path=csv_path):\n    result = pd.read_csv(\'{0}/yahoo_info.csv\'.format(csv_path), index_col=0)\n    result[\'Date\'] = pd.to_datetime(result[\'Date\'])\n\n    return result\n\n    \ndef get_yahoo_price(code, price_path=price_path):\n    result = pd.read_csv(\'{0}/y_{1}.csv\'.format(price_path, code), index_col=0)\n    result.index = pd.to_datetime(result.index)\n\n    return result\n\n    \n# 関数にretryデコレーターを付ける\n@retry(tries=5, delay=1, backoff=2)\ndef get_table(url):\n    result = pd.read_html(url, header=0) # header引数で0行目をヘッダーに指定。データフレーム型\n    \n    return result\n\n\ndef get_stock_table_yahoojp():\n    result = []\n    p = 1\n    base = \'http://stocks.finance.yahoo.co.jp/stocks/qi/?&p={0}\'\n\n    while True:\n        url = base.format(p)\n        # \'https://stocks.finance.yahoo.co.jp/stocks/qi/?&p=1\' # 2018-03-03 p=187まで\n        print(\'{0}: {1}\'.format(p, url))\n        tables = get_table(url)\n        if len(tables[2]) == 0:\n            break\n        result.append(tables[2])\n        p += 1\n        \n    result = pd.concat(result, ignore_index=True)\n    \n    result.columns = [\'code\', \'market\', \'name\', \'price\', \'extra\']\n    \n    result[\'code\'] = result[\'code\'].astype(int)\n    \n    result[\'market_code\'] = \'T\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'名\'), \'market_code\'] = \'N\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'大\'), \'market_code\'] = \'O\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'札\'), \'market_code\'] = \'S\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'福\'), \'market_code\'] = \'F\'\n        \n    return result\n\n\ndef get_etf_table_yahoojp():\n    result = []\n    p = 1\n    base = \'https://stocks.finance.yahoo.co.jp/etf/list/?p={0}\'\n\n    while True:\n        url = base.format(p)\n        # \'https://stocks.finance.yahoo.co.jp/etf/list/?p=1\' # 2018-03-09 p=5まで\n        print(\'{0}: {1}\'.format(p, url))\n        tables = get_table(url)\n        if len(tables[0]) == 0:\n            break\n        result.append(tables[0].iloc[:-1, :])\n        p += 1\n        \n    result = pd.concat(result, ignore_index=True)\n    \n    result.columns = [\'code\', \'market\', \'name\', \'連動対象\', \'価格更新日時\',\'price\',\n                      \'前日比\', \'前日比率\', \'売買単位\',\'運用会社\', \'信託報酬（税抜）\']\n    \n    result[\'code\'] = result[\'code\'].astype(int)\n    \n    result[\'market_code\'] = \'T\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'名\'), \'market_code\'] = \'N\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'大\'), \'market_code\'] = \'O\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'札\'), \'market_code\'] = \'S\'\n    result.loc[result[\'market\'].fillna("").str.contains(\'福\'), \'market_code\'] = \'F\'\n        \n    return result\n\n  \ndef get_price_yahoojp(code, market_code, start=None, end=None, interval=\'d\'):\n    # 参考: http://sinhrks.hatenablog.com/entry/2015/02/04/002258\n    # 参考: http://jbclub.xii.jp/?p=598\n    \n    # urlを準備\n    base = \'http://info.finance.yahoo.co.jp/history/?code={0}.{1}&{2}&{3}&tm={4}&p={5}\'\n\n    # 取得期間の設定\n    # start\n    if start == None:\n        start = pd.to_datetime(\'1980-01-01\')\n    else :\n        start = pd.to_datetime(start)\n    start = \'sy={0}&sm={1}&sd={2}\'.format(start.year, start.month, start.day) # \'sy=2017&sm=1&sd=1\'\n    \n    # end\n    if end == None:\n        end = pd.to_datetime(pd.datetime.now())\n    else :\n        end = pd.to_datetime(end)\n    end = \'ey={0}&em={1}&ed={2}\'.format(end.year, end.month, end.day)\n    \n    # 変数の設定\n    p = 1\n    tmp_result = []\n\n    # インターバルの設定\n    if interval not in [\'d\', \'w\', \'m\', \'v\']:\n        raise ValueError("Invalid interval: valid values are \'d\', \'w\', \'m\' and \'v\'")\n\n    # webサイトから価格テーブルを取得\n    while True:\n        url = base.format(code, market_code, start, end, interval, p)\n        # print(url)\n        # https://info.finance.yahoo.co.jp/history/?code=7203.T&sy=2000&sm=1&sd=1&ey=2017&em=10&ed=13&tm=d&p=1\n        tables = get_table(url)\n        if len(tables) < 2 or len(tables[1]) == 0:\n            # print(\'break\')\n            break\n        tmp_result.append(tables[1]) # ページ内の3つのテーブルのうち2番目のテーブルを連結\n        p += 1\n        # print(p)\n        \n    # 整形処理\n    result = pd.concat(tmp_result, ignore_index=True) # インデックスをゼロから振り直す\n    result.columns = [\'Date\', \'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\'] # 列名を変更\n    if interval == \'m\':\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'], format=\'%Y年%m月\')\n    else:\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'], format=\'%Y年%m月%d日\') # 日付の表記を変更\n    result = result.set_index(\'Date\') # インデックスを日付に変更\n    result = result.sort_index()\n    \n    # 銘柄名を変数に格納\n    stock_name = tables[0].columns[0]\n    # print([code, stock_name])\n    \n    return [result, stock_name]\n\n\ndef extract_price(tmp_price):\n    tmp_price = tmp_price[~tmp_price.isnull().any(axis=1)]\n        \n    # なぜか日付が重複した行が入る場合があるので確認、削除\n    tmp_price = tmp_price[~tmp_price.index.duplicated()]\n        \n    # 数値の列の数値以外の欠損値文字列 (\'---\' 等) を NaN に置換\n    for col in tmp_price:\n        if tmp_price[col].dtypes == object:\n            tmp_price.loc[tmp_price[col].str.isnumeric() == False, col] = np.nan\n            \n    # NaN が入る場合があるので価格列は float で統一\n    tmp_price = tmp_price.astype(float)\n        \n    return tmp_price\n\n\ndef reform_info(tmp_info, code, stock_name):\n    # 単列の場合、代入と同時に列を生成できるが、複数列の場合は存在しないとエラーになるので先に列を追加しなければいけない\n    # result = tmp_info.loc[:, [\'Code\', \'StockName\', \'Date\', \'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\']] # 列を追加、並べ替え\n    # result[[\'Code\', \'StockName\']] = [code, stock_name] # 複数列に値を代入する場合は列名をリスト形式で記述\n    tmp_info[\'Code\'] = code # float型になってしまうので変換\n    tmp_info[\'StockName\'] = stock_name\n    tmp_info = tmp_info[[\'Code\', \'StockName\', \'Date\', \'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\']] # 列を並べ替え\n            \n    return tmp_info\n\n\ndef complement_price(price_table):\n    # 出来高ゼロの日はインデックスごと欠落しているので、ビジネスデイ(freq=\'B\')のdatetime型インデックスにデータをあてはめる\n    # TODO 休日はどうするか要検討、japandas使ってみる\n    result = pd.DataFrame(price_table, index=pd.date_range(price_table.index[0], price_table.index[-1], freq=\'B\'))\n    \n    # 欠損データを補完する\n    # Volumeをゼロで補完\n    result.Volume = result.Volume.fillna(0)\n    \n    # Close,AdjCloseは前日データで補完\n    result[[\'Close\', \'AdjClose\']] = result[[\'Close\', \'AdjClose\']].fillna(method=\'ffill\') \n    \n    # 欠損Openを前日補完済み前日Closeで補完\n    result[\'Open\'] = result[\'Open\'].fillna(result[\'Close\'].shift(1))\n    \n    # High,Low,CloseはOpenで補完\n    result[[\'Open\', \'High\', \'Low\']] = result[[\'Open\', \'High\', \'Low\']].fillna(method=\'ffill\', axis=1)\n    \n    return result\n\n\ndef add_processed_price(price_table):\n    # 差分系列の作成\n\n    # 原系列\n    # 当日Close-前日Close\n    price_table[\'diff_close\'] = price_table[\'AdjClose\'].diff(1)\n    # Close-Open\n    price_table[\'open_close\'] = price_table[\'Close\'] - price_table[\'Open\']\n    # High-Low\n    price_table[\'range\'] = price_table[\'High\'] - price_table[\'Low\']\n    # 収益率 当日Close-前日Close\n    price_table[\'return_dc\'] = price_table[\'diff_close\'] / price_table[\'AdjClose\'].shift(1) * 100\n    # 収益率 Close-Open\n    price_table[\'return_oc\'] = price_table[\'open_close\'] / price_table[\'Open\'] * 100\n    # 比率 range/Open\n    price_table[\'ratio_range\'] = price_table[\'range\'] / price_table[\'Open\'] * 100\n    \n    # 対数系列\n    # 対数化 AdjClose\n    price_table[\'log_price\'] = np.log(price_table[\'AdjClose\'])\n    # 対数差収益率 当日Close-前日Close\n    price_table[\'log_return_dc\'] = price_table[\'log_price\'].diff(1) * 100\n    # 対数差収益率 Close-Open\n    price_table[\'log_return_oc\'] = (np.log(price_table[\'Close\']) - np.log(price_table[\'Open\'])) * 100\n    # 対数化 High-Low\n    # price_table[\'log_range\'] = np.log(price_table[\'High\']) - np.log(price_table[\'Low\'])\n    # 対数化比率 range / Open\n    # price_table[\'log_ratio_range\'] = (np.log(price_table[\'High\']) - np.log(price_table[\'Low\'])) / np.log(price_table[\'Open\']) * 100\n    \n    return price_table\n\n\ndef calc_adj_close(code):\n    info = get_yahoo_info()\n    price = get_yahoo_price(code)\n    \n    if info[\'Code\'].isin([code]).any():\n        info[\'s_rate\'] = info[\'Open\'].str.extract(\'-> ([0-9.]*)株\', expand=True).astype(float)\n        info = info[info[\'Code\'] == code].set_index(\'Date\')\n\n        price[\'s_rate\'] = info[\'s_rate\']\n        price[\'s_rate\'] = price[\'s_rate\'].fillna(1)\n        price[\'a_rate\'] = 1.0\n        # yahoo の正確な計算式は不明。誤差が発生する銘柄もある。桁数だけの問題ではなさそう。\n        for i in reversed(range(len(price) - 1)):\n            price[\'a_rate\'][i] = price[\'a_rate\'][i + 1] / price[\'s_rate\'][i + 1]\n        price[\'AdjClose\'] = np.round(price[\'Close\'] * price[\'a_rate\'], 2)\n        price = price[[\'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\']]\n    else:\n        print(\'code {0} has no info.\'.format(code))\n    \n    return price')

