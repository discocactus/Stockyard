
# coding: utf-8

# # stock.py

# In[ ]:


get_ipython().run_cell_magic('writefile', 'stock.py', '# coding: utf-8\n\nfrom __future__ import unicode_literals\nimport numpy as np\nimport pandas as pd\nimport pandas.tseries.offsets as offsets\nimport datetime as dt\nimport time\nimport importlib\nimport logging\nfrom retry import retry\n# import traceback\n# from retrying import retry\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.types import Date, Integer, Float, Text\n# from sqlalchemy.types import Integer\n# from sqlalchemy.types import Text\n\n\nclass sql:\n    db_settings = {\n        "db": \'mysql\', # ドライバーは mysqldb になる。mysqlclient のこと？\n        # "db": \'mysql+mysqlconnector\',\n        # "db": \'mysql+pymysql\',\n        # "host": \'localhost\',\n        "host": \'127.0.0.1\',\n        # "host": \'MyCon\',\n        # "database": \'StockPrice_Yahoo_1\',\n        "database": \'stockyard\',\n        "user": \'user\',\n        "password": \'password\',\n        "port": \'3306\',\n        "charset": \'?charset=utf8mb4\'\n    }\n    # engine = create_engine(\'mysql://{user}:{password}@{host}:{port}/{database}\'.format(**db_settings))\n    engine = create_engine(\'{db}://{user}:{password}@{host}:{port}/{database}{charset}\'.format(**db_settings))\n    \n    \n    def write_price(self, code, price):\n        table_name = \'t_{0}\'.format(code)\n        # sqlalchemy.typesで定義されたデータ型を辞書形式で設定\n        dtype = {\n            \'Date\': Date(),\n            \'Open\': Integer(),\n            \'High\': Integer(),\n            \'Low\': Integer(),\n            \'Close\': Integer(),\n            \'Volume\': Integer(),\n            \'AdjClose\': Float()\n        }\n        price.to_sql(table_name, sql.engine, if_exists=\'replace\', dtype=dtype)\n        # 主キーを設定\n        # 参考 https://stackoverflow.com/questions/30867390/python-pandas-to-sql-how-to-create-a-table-with-a-primary-key\n        with sql.engine.connect() as con:\n            con.execute(\'ALTER TABLE `{0}` ADD PRIMARY KEY (`Date`);\'.format(table_name))\n        \n\n    def get_price(self, code):\n        # table_name = \'t_{0}\'.format(code)\n        # result = pd.read_sql_table(table_name, sql.engine, index_col=\'Date\')#.drop(\'index\', axis=1)\n        sql_query = \'SELECT * FROM t_{0}\'.format(code)\n        result = pd.read_sql(sql_query, sql.engine, index_col=\'Date\')\n        \n        return result\n    \n    \n    def write_info(self, table_name, info):\n        # sqlalchemy.typesで定義されたデータ型を辞書形式で設定\n        dtype = {\n            \'Code\': Integer(),\n            \'StockName\': Text(),\n            \'Date\': Date(),\n            \'Open\': Text()}\n        \n        info.to_sql(table_name, sql.engine, if_exists=\'replace\', dtype=dtype)\n        \n        \n    def get_info(self, table_name):\n        # result = pd.read_sql_table(table_name, sql.engine, index_col=None).drop(\'index\', axis=1)\n        sql_query = \'SELECT * FROM {0}\'.format(table_name)\n        result = pd.read_sql(sql_query, sql.engine, index_col=\'index\')#.drop(\'index\', axis=1)\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'])\n        \n        return result\n    \n    \n    def get_yahoo_info(self):\n        # result = pd.read_sql_table(table_name, sql.engine, index_col=None).drop(\'index\', axis=1)\n        sql_query = \'SELECT * FROM yahoo_info\'\n        result = pd.read_sql(sql_query, sql.engine, index_col=\'index\')#.drop(\'index\', axis=1)\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'])\n        \n        return result\n        \n\n    def get_yahoo_stock_code(self, start_index=0, end_index=None):\n        # yahoo_stock_table = pd.read_sql_table(\'yahoo_stock_table\', sql.engine, index_col=None).drop(\'index\', axis=1)\n        sql_query = \'SELECT * FROM yahoo_stock_table\'\n        yahoo_stock_table = pd.read_sql(sql_query, sql.engine, index_col=\'index\')#.drop(\'index\', axis=1)\n        \n        if end_index == None:\n            end_index = len(yahoo_stock_table)\n\n        result = list(yahoo_stock_table[\'code\'][start_index : end_index])\n        \n        return result\n\n\n    def get_new_added_stock_code(self, start_index=0, end_index=None):\n        # new_added_stock_table = pd.read_sql_table(\'new_added_stock_table\', sql.engine, index_col=None).drop(\'index\', axis=1)\n        sql_query = \'SELECT * FROM new_added_stock_table\'\n        new_added_stock_table = pd.read_sql(sql_query, sql.engine, index_col=\'index\')#.drop(\'index\', axis=1)\n        \n        if end_index == None:\n            end_index = len(new_added_stock_table)\n\n        result = list(new_added_stock_table[\'code\'][start_index : end_index])\n        \n        return result\n\n\n    def statement_query(self, sql_query):\n        result = pd.read_sql_query(sql_query, sql.engine, index_col=None)\n        # ex. df = sql.statement_query(\'SELECT code, name FROM domestic_stock_table\')\n        # テーブル全体ではなく抽出の場合、インデックスは無いらしく下記ではエラーになる\n        #result = pd.read_sql_query(statement, sql.engine, index_col=None).drop(\'index\', axis=1)\n        \n        return result\n    \n    \n    def write_table(self, table_name, table):\n        table.to_sql(table_name, sql.engine, if_exists=\'replace\')\n        \n    \n    def read_table(self, table_name, index_col=None):\n        # result = pd.read_sql_table(table_name, sql.engine, index_col=index_col)\n        sql_query = \'SELECT * FROM {0}\'.format(table_name)\n        result = pd.read_sql(sql_query, sql.engine, index_col=index_col)\n        \n        return result\n    \n    \n# 関数にretryデコレーターを付ける\n@retry(tries=5, delay=1, backoff=2)\ndef get_table(url):\n    result = pd.read_html(url, header=0) # header引数で0行目をヘッダーに指定。データフレーム型\n    \n    return result\n\n\ndef get_price_yahoojp(code, start=None, end=None, interval=\'d\'): # start = \'2017-01-01\'\n    # http://sinhrks.hatenablog.com/entry/2015/02/04/002258\n    # http://jbclub.xii.jp/?p=598\n    base = \'http://info.finance.yahoo.co.jp/history/?code={0}.T&{1}&{2}&tm={3}&p={4}\'\n    \n    start = pd.to_datetime(start) # Timestamp(\'2017-01-01 00:00:00\')\n\n    if end == None:\n        end = pd.to_datetime(pd.datetime.now())\n    else :\n        end = pd.to_datetime(end)\n    start = \'sy={0}&sm={1}&sd={2}\'.format(start.year, start.month, start.day) # \'sy=2017&sm=1&sd=1\'\n    end = \'ey={0}&em={1}&ed={2}\'.format(end.year, end.month, end.day)\n    p = 1\n    tmp_result = []\n\n    if interval not in [\'d\', \'w\', \'m\', \'v\']:\n        raise ValueError("Invalid interval: valid values are \'d\', \'w\', \'m\' and \'v\'")\n\n    while True:\n        url = base.format(code, start, end, interval, p)\n        # print(url)\n        # https://info.finance.yahoo.co.jp/history/?code=7203.T&sy=2000&sm=1&sd=1&ey=2017&em=10&ed=13&tm=d&p=1\n        tables = get_table(url)\n        if len(tables) < 2 or len(tables[1]) == 0:\n            # print(\'break\')\n            break\n        tmp_result.append(tables[1]) # ページ内の3つのテーブルのうち2番目のテーブルを連結\n        p += 1\n        # print(p)\n        \n    result = pd.concat(tmp_result, ignore_index=True) # インデックスをゼロから振り直す\n\n    result.columns = [\'Date\', \'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\'] # 列名を変更\n    if interval == \'m\':\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'], format=\'%Y年%m月\')\n    else:\n        result[\'Date\'] = pd.to_datetime(result[\'Date\'], format=\'%Y年%m月%d日\') # 日付の表記を変更\n    result = result.set_index(\'Date\') # インデックスを日付に変更\n    result = result.sort_index()\n    \n    stock_name = tables[0].columns[0]\n    # print([code, stock_name])\n    \n    return [result, stock_name]\n\n\ndef extract_price(tmp_price):\n    # null が存在する行を取り除いて価格データとする 参考 https://qiita.com/u1and0/items/fd2780813b690a40c197\n    result = tmp_price[~tmp_price.isnull().any(axis=1)].astype(float).astype(int) # この場合、"~"は "== False" とするのと同じこと\n    # なぜか日付が重複した行が入る場合があるので確認、削除\n    if(result.index.duplicated().any()):\n        result = result[~result.index.duplicated()]\n        \n    return result\n\n\ndef reform_info(tmp_info, code, stock_name):\n    # 単列の場合、代入と同時に列を生成できるが、複数列の場合は存在しないとエラーになるので先に列を追加しなければいけない\n    result = tmp_info.ix[:, [\'Code\', \'StockName\', \'Date\', \'Open\', \'High\', \'Low\', \'Close\', \'Volume\', \'AdjClose\']] # 列を追加、並べ替え\n    result[[\'Code\', \'StockName\']] = [code, stock_name] # 複数列に値を代入する場合は列名をリスト形式で記述\n    result[\'Code\'] = result[\'Code\'].astype(int) # float型になってしまうので変換\n            \n    return result\n\n\ndef complement_price(price_table):\n    # 出来高ゼロの日はインデックスごと欠落しているので、ビジネスデイ(freq=\'B\')のdatetime型インデックスにデータをあてはめる\n    # TODO 休日はどうするか要検討、japandas使ってみる\n    result = pd.DataFrame(price_table, index=pd.date_range(price_table.index[0], price_table.index[-1], freq=\'B\'))\n    \n    # 欠損データを補完する\n    # Volumeをゼロで補完\n    result.Volume = result.Volume.fillna(0)\n    \n    # Close,AdjCloseは前日データで補完\n    result[[\'Close\', \'AdjClose\']] = result[[\'Close\', \'AdjClose\']].fillna(method=\'ffill\') \n    \n    # 欠損Openを前日補完済み前日Closeで補完\n    result[\'Open\'] = result[\'Open\'].fillna(result[\'Close\'].shift(1))\n    \n    # High,Low,CloseはOpenで補完\n    result[[\'Open\', \'High\', \'Low\']] = result[[\'Open\', \'High\', \'Low\']].fillna(method=\'ffill\', axis=1)\n    \n    return result\n\n\ndef add_processed_price(price_table):\n    # 差分系列の作成\n\n    # 原系列\n    # 当日Close-前日Close\n    price_table[\'diff_close\'] = price_table[\'AdjClose\'].diff(1)\n    # Close-Open\n    price_table[\'open_close\'] = price_table[\'Close\'] - price_table[\'Open\']\n    # High-Low\n    price_table[\'range\'] = price_table[\'High\'] - price_table[\'Low\']\n    # 収益率 当日Close-前日Close\n    price_table[\'return_dc\'] = price_table[\'diff_close\'] / price_table[\'AdjClose\'].shift(1) * 100\n    # 収益率 Close-Open\n    price_table[\'return_oc\'] = price_table[\'open_close\'] / price_table[\'Open\'] * 100\n    # 比率 range/Open\n    price_table[\'ratio_range\'] = price_table[\'range\'] / price_table[\'Open\'] * 100\n    \n    # 対数系列\n    # 対数化 AdjClose\n    price_table[\'log_price\'] = np.log(price_table[\'AdjClose\'])\n    # 対数差収益率 当日Close-前日Close\n    price_table[\'log_return_dc\'] = price_table[\'log_price\'].diff(1) * 100\n    # 対数差収益率 Close-Open\n    price_table[\'log_return_oc\'] = (np.log(price_table[\'Close\']) - np.log(price_table[\'Open\'])) * 100\n    # 対数化 High-Low\n    # price_table[\'log_range\'] = np.log(price_table[\'High\']) - np.log(price_table[\'Low\'])\n    # 対数化比率 range / Open\n    # price_table[\'log_ratio_range\'] = (np.log(price_table[\'High\']) - np.log(price_table[\'Low\'])) / np.log(price_table[\'Open\']) * 100\n    \n    return price_table')

